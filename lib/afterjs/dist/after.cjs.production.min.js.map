{"version":3,"file":"after.cjs.production.min.js","sources":["../src/NotFoundComponent.tsx","../src/utils.ts","../src/contexts/AfterContext.tsx","../src/Document.tsx","../src/ensureReady.ts","../src/loadInitialProps.tsx","../src/getAssets.ts","../src/loadStaticProps.ts","../src/After.tsx","../src/contexts/AfterRouterContext.tsx","../src/renderApp.tsx","../src/render.tsx","../src/renderStatic.tsx","../src/serializeData.tsx","../src/asyncComponent.tsx"],"sourcesContent":["import { Route } from 'react-router-dom';\r\n\r\nconst NotFound = () => {\r\n  const data = `The Page You Were Looking For Was Not Found`;\r\n  return <Route path='**' Component={() => data} />\r\n}\r\n\r\nexport default NotFound;\r\n","import {\r\n  AsyncRouteableComponent,\r\n  AsyncRouteComponentType,\r\n  AsyncRouteProps,\r\n  TransitionBehavior,\r\n} from './types';\r\nimport NotFoundComponent from './NotFoundComponent';\r\n\r\n/** @private is the given object a Function? */\r\nexport const isFunction = (obj: any) => 'function' === typeof obj;\r\n\r\n/** @private is the given object an Object? */\r\nexport const isObject = (obj: any) => obj !== null && typeof obj === 'object';\r\n\r\n/** @private is the given object/value a promise? */\r\nexport const isPromise = (value: any): boolean =>\r\n  isObject(value) && isFunction(value.then);\r\n\r\n/** @private we render on client? */\r\nexport const isDOM = (): boolean =>\r\n  typeof window === 'object' && typeof window.document === 'object';\r\n\r\n/** @private we render on server? */\r\nexport const isServer = (): boolean => !isDOM();\r\n\r\n/** @private Guard cluase to narrow the AsyncRouteableComponent union type on getInitialProps */\r\nexport function isAsyncComponent(\r\n  Component: AsyncRouteableComponent\r\n): Component is AsyncRouteComponentType<any> {\r\n  return (\r\n    (Component as AsyncRouteComponentType<any>).getInitialProps !== undefined\r\n  );\r\n}\r\n\r\n/** @private Guard cluase to narrow the AsyncRouteableComponent union type on load */\r\nexport function isLoadableComponent(\r\n  Component: AsyncRouteableComponent\r\n): Component is AsyncRouteComponentType<any> {\r\n  return (Component as AsyncRouteComponentType<any>).load !== undefined;\r\n}\r\n\r\n/** @private is given routes array have a 404 page?  */\r\nexport function is404ComponentAvailable(\r\n  routes: AsyncRouteProps<any>[]\r\n): AsyncRouteProps<any> | false {\r\n  return (\r\n    routes.find(route => ['**', '*', '', undefined].includes(route.path)) ||\r\n    false\r\n  );\r\n}\r\n\r\n/** @private Returns 404Component from given routes if component was not avaliable returns default 404component */\r\nexport function get404Component(\r\n  routes: AsyncRouteProps<any>[]\r\n): AsyncRouteableComponent<any> {\r\n  const match = is404ComponentAvailable(routes);\r\n  return match ? match.Component : NotFoundComponent;\r\n}\r\n\r\n/** @private Checks if 404Component is in routes, if it's not available add default 404 component */\r\nexport function getAllRoutes(\r\n  routes: AsyncRouteProps<any>[]\r\n): AsyncRouteProps<any>[] {\r\n  return is404ComponentAvailable(routes)\r\n    ? routes\r\n    : [...routes, { Component: NotFoundComponent }];\r\n}\r\n\r\n/** @private Checks if given string ends with \".js\" */\r\nexport function isJS(str: string) {\r\n  return str.endsWith('.js');\r\n}\r\n\r\n/** @private Checks if given transition type is instant */\r\nexport function isInstantTransition(transition: TransitionBehavior) {\r\n  return transition === \"instant\";\r\n}\r\n","import React from \"react\";\r\nimport { AfterContext } from \"../types\";\r\n\r\nexport const __AfterContext = React.createContext({} as AfterContext);\r\n\r\nexport const useAfterContext = () => {\r\n  return React.useContext(__AfterContext);\r\n};","import * as React from 'react';\r\nimport serialize from 'serialize-javascript';\r\nimport { isJS } from './utils';\r\nimport { DocumentProps, DocumentgetInitialProps } from './types';\r\nimport { useAfterContext } from './contexts/AfterContext';\r\n\r\nexport class Document extends React.Component<DocumentProps> {\r\n  static getInitialProps = async ({ renderPage }: DocumentgetInitialProps) => {\r\n    const page = await renderPage();\r\n    return { ...page };\r\n  };\r\n\r\n  render() {\r\n    const { helmet } = this.props;\r\n    // get attributes from React Helmet\r\n    const htmlAttrs = helmet.htmlAttributes.toComponent();\r\n    const bodyAttrs = helmet.bodyAttributes.toComponent();\r\n\r\n    return (\r\n      <html {...htmlAttrs}>\r\n        <head>\r\n          <meta httpEquiv=\"X-UA-Compatible\" content=\"IE=edge\" />\r\n          <meta charSet=\"utf-8\" />\r\n          <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\r\n          {helmet.title.toComponent()}\r\n          {helmet.meta.toComponent()}\r\n          {helmet.link.toComponent()}\r\n          <AfterStyles />\r\n        </head>\r\n        <body {...bodyAttrs}>\r\n          <AfterRoot />\r\n          <AfterData />\r\n          <AfterScripts />\r\n        </body>\r\n      </html>\r\n    );\r\n  }\r\n}\r\n\r\nexport const AfterRoot: React.FC = () => {\r\n  const { html } = useAfterContext();\r\n  return <div id=\"root\" dangerouslySetInnerHTML={{ __html: html }} />;\r\n};\r\n\r\nexport const AfterData: React.FC<{ data?: object }> = ({ data }) => {\r\n  const { data: contextData } = useAfterContext();\r\n  return (\r\n    <script\r\n      defer\r\n      dangerouslySetInnerHTML={{\r\n        __html: `window.__SERVER_APP_STATE__ =  ${serialize({\r\n          ...(data || contextData),\r\n        })}`,\r\n      }}\r\n    />\r\n  );\r\n};\r\n\r\nexport const AfterStyles: React.FC = () => {\r\n  const { assets, styles } = useAfterContext();\r\n  return (\r\n    <>\r\n      {assets.client.css && <link rel=\"stylesheet\" href={assets.client.css} />}\r\n      {styles.map(path => (\r\n        <link key={path} rel=\"stylesheet\" href={path} />\r\n      ))}\r\n    </>\r\n  );\r\n};\r\n\r\nexport const AfterScripts: React.FC = () => {\r\n  const { scripts, assets } = useAfterContext();\r\n  return (\r\n    <>\r\n      {scripts.filter(isJS).map(path => (\r\n        <script\r\n          key={path}\r\n          defer\r\n          type=\"text/javascript\"\r\n          src={path}\r\n          crossOrigin=\"anonymous\"\r\n        />\r\n      ))}\r\n      {assets.client.js && (\r\n        <script\r\n          type=\"text/javascript\"\r\n          src={assets.client.js}\r\n          defer\r\n          crossOrigin=\"anonymous\"\r\n        />\r\n      )}\r\n    </>\r\n  );\r\n};\r\n","import { matchPath } from 'react-router-dom';\r\nimport { AsyncRouteProps } from './types';\r\nimport { isLoadableComponent } from './utils';\r\n\r\n/**\r\n * This helps us to make sure all the async code is loaded before rendering.\r\n */\r\nexport async function ensureReady(\r\n  routes: AsyncRouteProps[],\r\n  pathname?: string\r\n) {\r\n  await Promise.all(\r\n    routes.map(route => {\r\n      //const match = matchPath(pathname || window.location.pathname, route);\r\n      const match = matchPath({\r\n        path: route.path || \"*\",\r\n        caseSensitive: route.caseSensitive,\r\n        end: true\r\n      }, pathname || window.location.pathname)\r\n      if (\r\n        match &&\r\n        route &&\r\n        route.Component &&\r\n        isLoadableComponent(route.Component) &&\r\n        route.Component.load\r\n      ) {\r\n        return route.Component.load();\r\n      }\r\n      return undefined;\r\n    })\r\n  );\r\n\r\n  return Promise.resolve(\r\n    (window as any).__SERVER_APP_STATE__ as Promise<any>[]\r\n  );\r\n}\r\n","import { matchPath, RouteProps } from 'react-router-dom';\r\nimport { AsyncRouteProps, InitialProps, CtxBase } from './types';\r\nimport { isAsyncComponent } from './utils';\r\n\r\nexport async function loadInitialProps(\r\n  pathname: string,\r\n  routes: AsyncRouteProps[],\r\n  ctx: CtxBase\r\n): Promise<InitialProps> {\r\n  const promises: Promise<any>[] = [];\r\n\r\n  const matchedComponent = routes.find((route: RouteProps) => {\r\n    \r\n    // Step 1: Find the matched component using matchPath and pathname\r\n    //const match = matchPath(pathname, { ...route, path: route.path || '*' });\r\n    const match = matchPath({\r\n      path: route.path || \"*\",\r\n      caseSensitive: route.caseSensitive,\r\n      end: true\r\n    }, pathname)\r\n\r\n    // Step 2: Check if match is found: if match is not found, then 'match' is null\r\n    // If match is found and route has asyncComponent\r\n    // then load the component and call its getInitialProps\r\n    if (match && route.Component && isAsyncComponent(route.Component)) {\r\n      const component = route.Component;\r\n\r\n      promises.push(\r\n        component.load\r\n          ? component\r\n              .load()\r\n              .then(() => component.getInitialProps({ match, ...ctx }))\r\n          : component.getInitialProps({ match, ...ctx })\r\n      );\r\n    }\r\n\r\n    return !!match;\r\n  });\r\n\r\n  return {\r\n    match: matchedComponent,\r\n    data: (await Promise.all(promises))[0],\r\n  };\r\n}\r\n","import { GetAssetsParams } from './types';\r\nimport { isLoadableComponent } from './utils';\r\n// @ts-ignore\r\nimport logger from 'dazzle-dev-utils/logger';\r\n\r\nexport const errorMeesage = `all async routes must have a chunkName property with value of /* webpackChunkName: \"MyChunkName\" */ check your routes config or use babel-plugin-after`;\r\n\r\nexport function getAssets({ route, chunks }: GetAssetsParams) {\r\n  let scripts: string[] = [];\r\n  let styles: string[] = [];\r\n\r\n  // if route.component is not an asyncComponent\r\n  // it's assets (JS and CSS files) will go into the\r\n  // main bundle.js and bundle.css ...\r\n  if (!route || !isLoadableComponent(route.Component)) {\r\n    return { scripts, styles };\r\n  }\r\n\r\n  const chunkName = route.Component.getChunkName();\r\n\r\n  // if component was LoadableComponent and chunkName was undefined\r\n  // print an error message to console so Developer can fix it\r\n  // todo add link to documentation or show more useful error message\r\n  if (chunkName === undefined) {\r\n    logger.error(errorMeesage);\r\n    throw new Error();\r\n  }\r\n\r\n  // we look for component assets from chunks.json\r\n  if (chunks[chunkName] && chunks[chunkName].js) {\r\n    scripts = chunks[chunkName].js;\r\n  }\r\n\r\n  if (chunks[chunkName] && chunks[chunkName].css) {\r\n    styles = chunks[chunkName].css;\r\n  }\r\n\r\n  return { scripts, styles };\r\n}\r\n","import { InitialData } from './types';\r\n\r\nconst PAGE_DATA_FILE_NAME = 'page-data.json';\r\n\r\n// TODO: for better performance we can check\r\n// and see if matchedRoute component have getInitialProps or not\r\n// if the page dose not have a getInitalProps, then page-data.json is empty\r\n\r\n/**\r\n * reads data from pathname/page-data.json file using (fetch method) and then return it\r\n * @param routes\r\n * @param pathname\r\n */\r\nexport async function loadStaticProps(\r\n  pathname: string\r\n): Promise<{ data: InitialData }> {\r\n  // in ssg mode there is always a file called page-data.json next to the\r\n  // page path that we have in our app this page-data.json file includes inital data that we need\r\n  // to inject to our components before we render the component\r\n  // if pathname equals \"/\" we are going to fetch data for https://page-data.json path\r\n  // which is WRONG so we fallback to empty string for index page /page-data.json\r\n  const PAGE_DATA_FILE_PATH = `${\r\n    pathname === '/' ? '' : pathname\r\n  }/${PAGE_DATA_FILE_NAME}`;\r\n  return fetch(PAGE_DATA_FILE_PATH)\r\n    .then(res => res.json())\r\n    .then(res => {\r\n      return { data: res };\r\n    });\r\n}\r\n","import { Navigate, Route, Routes, useLocation, useNavigationType, useParams } from \"react-router-dom\";\nimport { Location } from 'history';\nimport { AsyncRouteProps, CtxBase, InitialData, ServerAppState, TransitionBehavior } from \"./types\";\nimport React from \"react\";\nimport { get404Component, getAllRoutes, isInstantTransition } from \"./utils\";\nimport { loadStaticProps } from \"./loadStaticProps\";\nimport { loadInitialProps } from \"./loadInitialProps\";\n\nconst isClient = typeof window !== \"undefined\";\n\nexport type AfterpartyProps = {\n  data: ServerAppState;\n  routes: AsyncRouteProps[];\n  transitionBehavior: TransitionBehavior;\n  customParams?: { [key: string]: any };\n}\n\nexport type AfterpartyState = {\n  data?: InitialData;\n  previousLocation: Location | null;\n  currentLocation: Location;\n  isLoading: boolean;\n}\n\n// HACK: Since there will always be a single instance of After, this shouldn't cause problems\nconst store = (() => {\n  let s: { [key: string]: object } = {};\n  return {\n    set: (key: string, value: object) => {\n      if (!isClient) {\n        console.log(\"ALERT: TRIED TO SET STORE ON SERVER\");\n        return;\n      }\n      s[key] = value;\n    },\n    get: (key: string) => {\n      if (!isClient) {\n        console.log(\"ALERT: TRIED TO GET STORE ON SERVER\");\n        return null;\n      }\n      return s[key];\n    }\n  }\n})();\n\nconst getCachedData = (navigationAction: string, location: Location) => {\n  if (navigationAction !== 'POP') return null;\n  const cache = store.get(location.pathname) as any;\n  // TODO: TTL on cache\n  return cache && cache.key === location.key ? cache.data : null;\n}\n\nconst defaultNavigatigationDetector = (currentLoc: Location, nextLoc: Location) => {\n  return nextLoc.pathname !== currentLoc.pathname || currentLoc.search !== nextLoc.search\n}\n\nexport const After = (props: AfterpartyProps) => {\n  const navigationType = useNavigationType();\n  const currentLocation = useLocation();\n  const params = useParams();\n\n  const { data, routes, transitionBehavior = 'blocking', customParams } = props;\n  const [state, setState] = React.useState<AfterpartyState>({\n    data: data.initialData,\n    previousLocation: null,\n    currentLocation,\n    isLoading: false\n  });\n\n  const hasNavigated = defaultNavigatigationDetector(currentLocation, state.currentLocation);\n\n  const initialData = state.data as any;\n  const isInstantMode = isInstantTransition(transitionBehavior);\n  const match = { params, pathname: currentLocation.pathname };\n  const NotfoundComponent: React.ComponentType<any> = get404Component(routes);\n\n  // when hasNavigated changes, then update the state and cached data accordingly\n  React.useEffect(() => {\n    const previousLocation = state.currentLocation;\n\n    if (hasNavigated) {\n      const cachedData = getCachedData(navigationType, currentLocation);\n      const hasCachedData = !!cachedData;\n      // update the current state\n      setState({\n        ...state,\n        previousLocation: hasCachedData ? null : previousLocation,\n        currentLocation,\n        data: cachedData,\n        isLoading: hasCachedData ? false : true\n      });\n    }\n  }, [hasNavigated]);\n\n  // this useEffect is similar to componentDidUpdate and must be fired only after\n  // update to state has happened\n  // in above useEffect\n  React.useEffect(() => {\n    const hasNavigated = state.previousLocation !== null && defaultNavigatigationDetector(state.previousLocation, state.currentLocation);\n    if (hasNavigated) {\n      const isBlockedMode = !isInstantMode;\n      const { scrollToTop, ssg } = data.afterData;\n\n      const ctx: CtxBase = {\n        location: currentLocation,\n        scrollToTop: scrollToTop,\n        customParams,\n      }\n\n      // Only for page changes, prevent scroll up for anchor links\n      const isPageChanged: boolean =\n        !!state.previousLocation &&\n        (state.previousLocation.pathname !== currentLocation.pathname);\n      const isAllowedToScroll: boolean =\n        isPageChanged && scrollToTop.current === true;\n\n      // in instant mode, first we scroll to top then we fetch the data\n      if (isInstantMode && isAllowedToScroll) {\n        window.scrollTo(0, 0);\n      }\n\n      if (state.data === null) {\n        // in ssg mode we don't call component.getInitialProps\n        // instead we fetch the page-data.json file\n        const loadData = ssg ? loadStaticProps : loadInitialProps;\n\n        loadData(currentLocation.pathname, routes, ctx)\n          .then(res => res.data)\n          .then((data: InitialData) => {\n            // if user moved to a new page at the time we were fetching data\n            // for the previous page, we ignore data of the previous page\n            if (state.currentLocation !== currentLocation) return;\n\n            // in blocked mode, first we fetch the data and then we scroll to top\n            if (isBlockedMode && isAllowedToScroll) {\n              window.scrollTo(0, 0);\n            }\n\n            if (!!data) {\n              store.set(correctLocation.pathname, { key: currentLocation.key, data })\n            }\n            setState({ previousLocation: null, data, isLoading: false, currentLocation });\n          })\n          .catch((e: Error) => {\n            // @todo we should more cleverly handle errors???\n            console.log(e);\n            setState({ previousLocation: null, data: undefined, isLoading: false, currentLocation });\n          });\n      }\n    }\n  }, [state]);\n\n  const updateState = React.useCallback((data: any) => {\n    if (!!data) {\n      store.set(currentLocation.pathname, { key: currentLocation.key, data });\n    }\n    setState({ ...state, previousLocation: null, data, isLoading: false, currentLocation })\n  }, [state, currentLocation]);\n\n  // used to refetch data for current route -> basically call loadData once again\n  const refetch = React.useCallback(() => {\n    const { scrollToTop, ssg } = data.afterData;\n\n    const ctx: CtxBase = {\n      location: currentLocation,\n      scrollToTop: scrollToTop,\n      customParams,\n    }\n    setState({ ...state, isLoading: true });\n\n    // in ssg mode we don't call component.getInitialProps\n    // instead we fetch the page-data.json file\n    const loadData = ssg ? loadStaticProps : loadInitialProps;\n\n    loadData(currentLocation.pathname, routes, ctx)\n      .then(res => res.data)\n      .then((data: InitialData) => {\n        // if user moved to a new page at the time we were fetching data\n        // for the previous page, we ignore data of the previous page\n        if (state.currentLocation !== currentLocation) return;\n\n        if (!!data) {\n          store.set(correctLocation.pathname, { key: currentLocation.key, data })\n        }\n        setState({ previousLocation: null, data, isLoading: false, currentLocation });\n      })\n      .catch((e: Error) => {\n        // @todo we should more cleverly handle errors???\n        console.log(e);\n        setState({ ...state, previousLocation: null, isLoading: false, currentLocation });\n      });\n  }, [state, currentLocation, data]);\n\n  // when we are in the instant mode we want to pass the right location prop\n  // to the <Route /> otherwise it will render previous matched component\n  const correctLocation = isInstantMode\n    ? currentLocation\n    : (state.previousLocation ? state.previousLocation : currentLocation);\n\n  return (\n    <Routes location={correctLocation}>\n      {initialData?.statusCode === 404 && (\n        <Route Component={NotfoundComponent} path={currentLocation.pathname} />\n      )}\n      {initialData?.redirectTo && (\n        <Navigate to={initialData.redirectTo} />\n      )}\n      {getAllRoutes(routes).map((route, index) => {\n        const Component = route.Component;\n        return (\n          <Route\n            path={route.path}\n            key={`route--${index}`}\n\t\t\t\t\t\telement={\n\t\t\t\t\t\t\t<Component\n\t\t\t\t\t\t\t\t{...initialData}\n\t\t\t\t\t\t\t\tmatch={match}\n\t\t\t\t\t\t\t\tlocation={currentLocation}\n\t\t\t\t\t\t\t\tisLoading={state.isLoading}\n\t\t\t\t\t\t\t\t// custom props\n\t\t\t\t\t\t\t\tupdateState={updateState}\n\t\t\t\t\t\t\t\trefetch={refetch}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t}\n            // Component={() => {\n            //   return (\n            //     <Component\n            //       {...initialData}\n            //       match={match}\n            //       location={currentLocation}\n            //       isLoading={state.isLoading}\n            //       // custom props\n            //       updateState={updateState}\n            //       refetch={refetch}\n            //     />\n            //   )\n            // }}\n          />\n        )\n      })}\n    </Routes>\n  )\n\n}\n\nexport default After;\n","import React from \"react\";\r\nimport { AfterRouterContext } from \"../types\";\r\n\r\nexport const __AfterRouterContext = React.createContext({} as AfterRouterContext);\r\n\r\nexport const useAfterRouterContext = () => {\r\n  return React.useContext(__AfterRouterContext);\r\n}","import * as React from 'react';\r\nimport * as ReactDOMServer from 'react-dom/server';\r\nimport { Helmet } from 'react-helmet';\r\nimport { StaticRouter } from 'react-router-dom/server';\r\nimport { matchPath } from 'react-router-dom';\r\n\r\nimport { Document as DefaultDoc } from './Document';\r\nimport After from './After';\r\nimport { loadInitialProps } from './loadInitialProps';\r\nimport * as utils from './utils';\r\n\r\nimport {\r\n  AfterRenderAppOptions,\r\n  AfterClientData,\r\n  CtxBase,\r\n  AsyncRouteProps,\r\n  RedirectWithStatuCode,\r\n  ServerAppState,\r\n  RenderResult,\r\n  DocumentProps,\r\n  RenderPageResult,\r\n  AfterRouterContext,\r\n} from './types';\r\n\r\nimport { getAssets } from './getAssets';\r\nimport { __AfterContext } from './contexts/AfterContext';\r\nimport { __AfterRouterContext } from './contexts/AfterRouterContext';\r\n\r\nconst modPageFn = function <Props>(Page: React.ComponentType<Props>) {\r\n  return function RenderAfter(props: Props) {\r\n    //@ts-ignore\r\n    return <Page {...props} />;\r\n  };\r\n};\r\n\r\n/**\r\n * The customRenderer parameter is a (potentially async) function that can be set to return\r\n * more than just a rendered string.\r\n * If present, it will be used instead of the default ReactDOMServer renderToString function.\r\n * It has to return an object of shape { html, ... }, in which html will be used as the rendered string\r\n * Other props will be also pass to the Document component\r\n */\r\nexport async function renderApp<T>(\r\n  options: AfterRenderAppOptions<T>\r\n): Promise<RenderResult> {\r\n  const {\r\n    req,\r\n    res,\r\n    routes: pureRoutes,\r\n    assets,\r\n    document: Document,\r\n    customRenderer,\r\n    chunks,\r\n    scrollToTop = true,\r\n    ssg = false,\r\n    customParams = {},\r\n  } = options;\r\n  const autoScrollRef: React.Ref<boolean> = { current: scrollToTop };\r\n\r\n  // check and see if 404 page is in list of app routes\r\n  // if there are no 404 page in routes array add After.js default 404 page\r\n  const routes: AsyncRouteProps[] = utils.getAllRoutes(pureRoutes);\r\n\r\n  const ctx: CtxBase = {\r\n    req,\r\n    res,\r\n    scrollToTop: autoScrollRef,\r\n    customParams,\r\n  };\r\n  \r\n  const fullUrl = req.protocol + '://' + req.get('host') + req.originalUrl;\r\n  const pathname = (new URL(fullUrl)).pathname;\r\n  //const pathname: string = url.parse(req.url).pathname as string;\r\n\r\n  // finds related component for the current path (request url)\r\n  // and calls component.getInitialProps({ match,...ctx })\r\n  const { match, data: initialData } = await loadInitialProps(\r\n    pathname,\r\n    routes,\r\n    ctx\r\n  );\r\n\r\n  // AfterRouterContextProvider context object contains information about statusCode and target <Navigate /> component target url (if any)\r\n  const context: AfterRouterContext = {};\r\n\r\n  // here we will check result of the getInitialProps\r\n  // and see if it contains redirectTo or statusCode properties\r\n  // we will mutate context if we got redirectTo or statusCode in initialData\r\n  if (initialData) {\r\n    const { redirectTo, statusCode } = initialData as RedirectWithStatuCode;\r\n\r\n    if (statusCode) {\r\n      context.statusCode = statusCode;\r\n    }\r\n\r\n    // if we got redirectTo from getInitalProps\r\n    // we don't waste server resources by rendering the react tree\r\n    // so we return early\r\n    if (redirectTo) {\r\n      return {\r\n        html: '',\r\n        data: initialData,\r\n        redirect: redirectTo,\r\n        statusCode: statusCode || 302,\r\n      };\r\n    }\r\n  }\r\n\r\n  // this object containes data that <After /> will use on client-side\r\n  const afterData: AfterClientData = {\r\n    scrollToTop: autoScrollRef,\r\n  };\r\n\r\n  // well, we will save a few bits in this way\r\n  if (ssg) {\r\n    afterData.ssg = true;\r\n  }\r\n\r\n  // result of getInitialProps + <After /> props\r\n  const data: ServerAppState = {\r\n    initialData,\r\n    afterData,\r\n  };\r\n\r\n  const renderPage = async (fn = modPageFn) => {\r\n    // By default, we keep ReactDOMServer synchronous renderToString function\r\n    const defaultRenderer = (element: React.ReactElement<T>) => ({\r\n      html: ReactDOMServer.renderToString(element),\r\n    });\r\n    const renderer = customRenderer || defaultRenderer;\r\n    const asyncOrSyncRender = renderer(\r\n      <__AfterRouterContext.Provider value={context}>\r\n        <StaticRouter location={req.url}>\r\n          {fn(After)({ routes, data, transitionBehavior: 'blocking', customParams })}\r\n        </StaticRouter>\r\n      </__AfterRouterContext.Provider>\r\n    );\r\n\r\n    const renderedContent = await asyncOrSyncRender;\r\n    const helmet = Helmet.renderStatic();\r\n\r\n    return { helmet, ...renderedContent };\r\n  };\r\n\r\n  const Doc = Document || DefaultDoc;\r\n\r\n  // get css and javascript file paths for the async componetns\r\n  const { scripts, styles } = getAssets({ route: match, chunks });\r\n\r\n  //const reactRouterMatch = matchPath(req.url, match as RouteProps);\r\n  const reactRouterMatch = matchPath({\r\n    path: match ? (match.path || \"*\") : \"*\",\r\n    caseSensitive: match ? match.caseSensitive : false,\r\n    end: true\r\n  }, pathname)\r\n\r\n  // Docuement.getInitialProps() will call renderPage()\r\n  // and renderPage() will call ReactDOMServer.renderToString\r\n  // so we get our React Tree html from this function\r\n  const { html, ...docProps } = await Doc.getInitialProps({\r\n    req,\r\n    res,\r\n    assets,\r\n    renderPage,\r\n    data,\r\n    helmet: Helmet.renderStatic(),\r\n    match: reactRouterMatch,\r\n    scripts,\r\n    styles,\r\n    scrollToTop: autoScrollRef,\r\n    customParams,\r\n  });\r\n\r\n  // if we got a <Redirect /> in during render of the react tree\r\n  // we redirect the user and we don't waste server resources\r\n  if (context.url) {\r\n    return {\r\n      html: '',\r\n      data: initialData,\r\n      redirect: context.url,\r\n      statusCode: context.statusCode || 302,\r\n    };\r\n  }\r\n\r\n  const props: DocumentProps<RenderPageResult> = {\r\n    assets,\r\n    data,\r\n    scripts,\r\n    styles,\r\n    match: reactRouterMatch,\r\n    customParams,\r\n    ...docProps,\r\n    html,\r\n  };\r\n\r\n  // we render <Document /> which is our app shell\r\n  const doc = ReactDOMServer.renderToStaticMarkup(\r\n    <__AfterContext.Provider value={props}>\r\n      <Doc {...props} />\r\n    </__AfterContext.Provider>\r\n  );\r\n\r\n  const page = `<!doctype html>${doc}`;\r\n\r\n  return {\r\n    html: page,\r\n    data: initialData,\r\n    redirect: '',\r\n    statusCode: context.statusCode || 200,\r\n  };\r\n}\r\n","import { renderApp } from './renderApp';\r\nimport { AfterRenderOptions } from './types';\r\n\r\nexport const render = async <T extends any>(\r\n  params: Omit<AfterRenderOptions<T>, 'ssg'>\r\n) => {\r\n  const { res } = params;\r\n  const { redirect, statusCode, html } = await renderApp({\r\n    ...params,\r\n    ssg: false,\r\n  });\r\n\r\n  if (redirect) {\r\n    res.redirect(statusCode, redirect);\r\n  }\r\n\r\n  res.status(statusCode);\r\n\r\n  return html;\r\n};\r\n","import { renderApp } from './renderApp';\r\nimport { AfterRenderStaticOptions } from './types';\r\n\r\nexport const renderStatic = async <T extends any>(\r\n  params: AfterRenderStaticOptions<T>\r\n) => {\r\n  const { redirect, html, data } = await renderApp({ ...params, ssg: true });\r\n\r\n  if (redirect) {\r\n    const { url } = params.req;\r\n    throw new Error(\r\n      `You are not allowed to use redirect in ssg mode, URL: ${url}`\r\n    );\r\n  }\r\n\r\n  return { html, data };\r\n};\r\n","import React from 'react';\r\nimport serialize from 'serialize-javascript';\r\n\r\ninterface SerializeData\r\n  extends React.DetailedHTMLProps<\r\n    React.ScriptHTMLAttributes<HTMLScriptElement>,\r\n    HTMLScriptElement\r\n  > {\r\n  name: string;\r\n  data: any;\r\n}\r\n\r\nexport const SerializeData: React.FC<SerializeData> = ({\r\n  data,\r\n  name,\r\n  ...props\r\n}) => {\r\n  return (\r\n    <script\r\n      defer\r\n      {...props}\r\n      dangerouslySetInnerHTML={{\r\n        __html: `window._${name.toUpperCase()}_ = ${serialize(data)}`,\r\n      }}\r\n    />\r\n  );\r\n};\r\n\r\nexport const getSerializedData = (name: string, remove = true): any => {\r\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n  // @ts-ignore\r\n  const data = window[`_${name.toUpperCase()}_`];\r\n  if (remove) {\r\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n    // @ts-ignore\r\n    delete window[`_${name.toUpperCase()}_`];\r\n  }\r\n  return data;\r\n};\r\n","import * as React from 'react';\r\nimport {\r\n  Module,\r\n  AsyncRouteComponentState,\r\n  AsyncRouteComponentType,\r\n  Ctx,\r\n} from './types';\r\n\r\n/**\r\n * Returns a new React component, ready to be instantiated.\r\n * Note the closure here protecting Component, and providing a unique\r\n * instance of Component to the static implementation of `load`.\r\n */\r\nexport function asyncComponent<Props>({\r\n  loader,\r\n  Placeholder,\r\n  chunkName,\r\n}: {\r\n  loader: () => Promise<Module<React.ComponentType<Props>>>;\r\n  Placeholder?: React.ComponentType<Props>;\r\n  chunkName?: string;\r\n}) {\r\n  // keep Component in a closure to avoid doing this stuff more than once\r\n  let Component: AsyncRouteComponentType<Props> | null = null;\r\n\r\n  return class AsyncRouteComponent extends React.Component<\r\n    Props,\r\n    AsyncRouteComponentState\r\n  > {\r\n    /**\r\n     * Static so that you can call load against an uninstantiated version of\r\n     * this component. This should only be called one time outside of the\r\n     * normal render path.\r\n     */\r\n    static load() {\r\n      return loader().then(ResolvedComponent => {\r\n        Component = ResolvedComponent.default || ResolvedComponent;\r\n      });\r\n    }\r\n\r\n    static getChunkName() {\r\n      return chunkName;\r\n    }\r\n\r\n    static getInitialProps(ctx: Ctx<any>) {\r\n      // Need to call the wrapped components getInitialProps if it exists\r\n      if (Component !== null) {\r\n        return Component.getInitialProps\r\n          ? Component.getInitialProps(ctx)\r\n          : Promise.resolve(null);\r\n      }\r\n    }\r\n\r\n    state = {\r\n      Component,\r\n    };\r\n\r\n    componentDidMount() {\r\n      AsyncRouteComponent.load().then(this.updateState);\r\n    }\r\n\r\n    updateState = () => {\r\n      // Only update state if we don't already have a reference to the\r\n      // component, this prevent unnecessary renders.\r\n      if (this.state.Component !== Component) {\r\n        this.setState({\r\n          Component,\r\n        });\r\n      }\r\n    };\r\n\r\n    render() {\r\n      const { Component: ComponentFromState } = this.state;\r\n\r\n      if (ComponentFromState) {\r\n        return <ComponentFromState {...this.props} />;\r\n      }\r\n\r\n      if (Placeholder) {\r\n        return <Placeholder {...this.props} />;\r\n      }\r\n\r\n      return null;\r\n    }\r\n  };\r\n}\r\n"],"names":["NotFound","React","Route","path","Component","isAsyncComponent","undefined","getInitialProps","isLoadableComponent","load","is404ComponentAvailable","routes","find","route","includes","getAllRoutes","concat","NotFoundComponent","isJS","str","endsWith","__AfterContext","createContext","useAfterContext","useContext","Document","_React$Component","apply","arguments","_inheritsLoose","prototype","render","helmet","this","props","htmlAttrs","htmlAttributes","toComponent","bodyAttrs","bodyAttributes","httpEquiv","content","charSet","name","title","meta","link","AfterStyles","AfterRoot","AfterData","AfterScripts","_ref2","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_ref","renderPage","wrap","_context","prev","next","abrupt","_extends","sent","stop","_x","_useAfterContext","id","dangerouslySetInnerHTML","__html","html","_ref3","data","_useAfterContext2","defer","serialize","_useAfterContext3","assets","styles","client","css","rel","href","map","key","_useAfterContext4","scripts","filter","type","src","crossOrigin","js","_ensureReady","pathname","Promise","all","matchPath","caseSensitive","end","window","location","resolve","__SERVER_APP_STATE__","loadInitialProps","_x2","_x3","_loadInitialProps","ctx","promises","matchedComponent","match","component","push","then","t0","t1","errorMeesage","getAssets","chunks","chunkName","getChunkName","logger","error","Error","loadStaticProps","_loadStaticProps","fetch","res","json","isClient","store","s","set","value","console","log","get","defaultNavigatigationDetector","currentLoc","nextLoc","search","After","navigationType","useNavigationType","currentLocation","useLocation","params","useParams","_props$transitionBeha","transitionBehavior","customParams","_React$useState","useState","initialData","previousLocation","isLoading","state","setState","hasNavigated","isInstantMode","NotfoundComponent","get404Component","useEffect","cachedData","navigationAction","cache","getCachedData","hasCachedData","isBlockedMode","_data$afterData","afterData","scrollToTop","ssg","isAllowedToScroll","current","scrollTo","correctLocation","e","updateState","useCallback","refetch","_data$afterData2","Routes","statusCode","redirectTo","Navigate","to","index","element","__AfterRouterContext","modPageFn","Page","renderApp","_renderApp","_callee2","options","req","customRenderer","_options$scrollToTop","_options$ssg","_options$customParams","autoScrollRef","fullUrl","_yield$loadInitialPro","context","Doc","_getAssets","reactRouterMatch","_yield$Doc$getInitial","docProps","doc","_context2","document","utils","protocol","originalUrl","URL","redirect","fn","defaultRenderer","asyncOrSyncRender","renderedContent","ReactDOMServer","Provider","StaticRouter","url","Helmet","renderStatic","DefaultDoc","_objectWithoutPropertiesLoose","_excluded","_yield$renderApp","status","toUpperCase","loader","Placeholder","AsyncRouteComponent","_this","ResolvedComponent","_proto","componentDidMount","ComponentFromState","remove"],"mappings":"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"}